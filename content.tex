%!TEX root = problems.tex


\begin{questions}

\question
Re-write the following expressions in Scheme and evaluate them using a Scheme interpreter/compiler.
\begin{parts}
  \part $(3 \times (5 + (10 \div 5)))$
  \part $(2 + 3 + 4 + 5)$
  \part $(1 + (5 + (2 + (10 \div 3))))$
  \part $(1 + (5 + (2 + (10 \div 3.0))))$
  \part $(3 + 5) \times (10 \div 2)$
  \part $(3 + 5) \times (10 \div 2) + (1 + (5 + (2 + (10 \div 3))))$
\end{parts}


\begin{solution}
\begin{parts}
  \part \mintinline{scheme}{(* (+ (/ 10 5) 5) 3)}
  \part \mintinline{scheme}{(+ 2 3 4 5)}
  \part \mintinline{scheme}{(+ (+ (+ (+ (/ 10 3) 2) 5) 1)}
  \part \mintinline{scheme}{(+ (+ (+ (+ (/ 10 3.0) 2) 5) 1)}
  \part \mintinline{scheme}{(* (+ 3 5) (/ 10 2))}
  \part \mintinline{scheme}{(+ (* (+ 3 5) (/ 10 2)) (+ (+ (+ (+ (/ 10 3) 2) 5) 1))}
\end{parts}
\end{solution}


\question
Define a procedure \mintinline{scheme}{discount} that takes two arguments: an item’s initial price and a percentage discount \cite{simplyscheme}.
It should return the new price:
\begin{minted}{scheme}
> (discount 10 5)
9.50
> (discount 29.90 50)
14.95
\end{minted}


\begin{solution}
  \begin{minted}{scheme}
(define (discount p d)
  (* p (- 1 (/ d 100.0)))
)
  \end{minted}
\end{solution}

\question
Write a function called \mintinline{scheme}{appearances} that returns the number of times its first argument appears as a member of its second argument~\cite{simplyscheme}.

\begin{solution}
  \begin{minted}{scheme}
(define (appearances i l)
  (if (null? l)
    0
    (if (equal? i (car l))	
      (+ 1 (appearances i (cdr l)))
      (appearances i (cdr l))
    )
  )
)   
  \end{minted}
\end{solution}

\question
Write a procedure \mintinline{scheme}{inter} that takes two lists as arguments.
It should return a list containing every element that appears in both lists, exactly once.

\begin{solution}
  \begin{minted}{scheme}

  \end{minted}
\end{solution}

\question
Write a procedure \mintinline{scheme}{noatoms} that takes a list and returns the number of atoms it contains.

\begin{solution}
  \begin{minted}{scheme}
  
  \end{minted}
\end{solution}

\question
Here is a Scheme procedure that never finishes its job:
\begin{minted}{scheme}
(define (forever n)
  (if (= n 0)
       1
       (+ 1 (forever n))))
\end{minted}
Explain why it doesn’t give any result\cite{simplyscheme}.

\question
Write a function called \mintinline{scheme}{range} that takes an integer $n$ and returns a list containing the atoms 1, 2, 3, \ldots, $n$.

\question
Write a function called \mintinline{scheme}{reversel} that takes a list and returns it reversed.	

\question
If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9.
The sum of these multiples is 23.
Write a procedure to find the sum of all the multiples of 3 or 5 below 1000~\cite{projecteuler}.

\begin{solution}
  \begin{minted}{scheme}
(define 
  (sum35 n)
    (if (= 0 n)
      0
      (if (= 0 (modulo n 3))
      (+ n (sum35 (- n 1)))
      (if (= 0 (modulo n 5))
      (+ n (sum35 (- n 1)))
      (sum35 (- n 1))))))
  \end{minted}
\end{solution}

\question
Write a procedure called \mintinline{scheme}{flatten} that takes as its argument a list, possibly including sublists, but whose ultimate building blocks are atoms.
It should return a sentence containing all the atoms of the list, in the order in which they appear in the original:
\begin{minted}{scheme}
> (flatten '(((a b) c (d e)) (f g) ((((h))) (i j) k)))
(a b c d e f g h i j k)
\end{minted}


\question
Each new term in the Fibonacci sequence is generated by adding the previous two terms.
By starting with 1 and 2, the first 10 terms will be:
\[ 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, \ldots \]
By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms~\cite{projecteuler}.

\question
Write a procedure \mintinline{scheme}{to-binary}:
\begin{minted}{scheme}
> (to-binary 9)
1001
> (to-binary 23)
10111
\end{minted}

\begin{solution}
  \begin{minted}{scheme}

  \end{minted}
\end{solution}

\question
Write Heap's algorithm for generating permutations in Scheme.

\begin{solution}
  \begin{minted}{scheme}
(define (perm s)
(cond ((null? s) '())
((null? (cdr s)) (list s))
(else ;; extract each item in list in turn and perm the rest
(let splice ((l '()) (m (car s)) (r (cdr s)))
(append
(map (lambda (x) (cons m x)) (perm (append l r)))
(if (null? r) '()
(splice (cons m l) (car r) (cdr r))))))))

(perm '(1 2 3))
  \end{minted}
\end{solution}

\end{questions}

\begin{thebibliography}{12}
  
\bibitem{simplyscheme}
  Brian Harvey and Matt Wright,
  \emph{Simply Scheme: Introducing Computer Science},
  MIT,
  1999.
  
\bibitem{projecteuler}
  Project Euler,
  \emph{Project Euler},
  2016.

\end{thebibliography}
